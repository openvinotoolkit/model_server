diff --git a/.gitignore b/.gitignore
index 1b482f038..d0fe70060 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,4 +5,5 @@
 /tags
 CMakeSettings.json
 .vs
+.vscode
 .idea
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 31da49a88..d61c9735e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -121,11 +121,6 @@ include(ExperimentalFeatures)
 
 add_subdirectory(src)
 
-if(BUILD_TESTS)
-	enable_testing()
-	add_subdirectory(tests)
-endif()
-
 if(BUILD_EXAMPLES)
 	add_subdirectory(examples)
 endif()
diff --git a/include/git2/sys/filter.h b/include/git2/sys/filter.h
index 60466d173..a35ad5f98 100644
--- a/include/git2/sys/filter.h
+++ b/include/git2/sys/filter.h
@@ -32,11 +32,19 @@ GIT_EXTERN(git_filter *) git_filter_lookup(const char *name);
 /** The "ident" filter */
 #define GIT_FILTER_IDENT "ident"
 
+/** The "lfs" filter */
+#define GIT_FILTER_LFS "lfs"
+
 /**
  * This is priority that the internal CRLF filter will be registered with
  */
 #define GIT_FILTER_CRLF_PRIORITY 0
 
+/**
+ * This is priority that the internal CRLF filter will be registered with
+ */
+#define GIT_FILTER_LFS_PRIORITY 199
+
 /**
  * This is priority that the internal ident filter will be registered with
  */
diff --git a/src/cli/cmd_clone.c b/src/cli/cmd_clone.c
index c18cb28d4..286fa7153 100644
--- a/src/cli/cmd_clone.c
+++ b/src/cli/cmd_clone.c
@@ -146,6 +146,7 @@ int cmd_clone(int argc, char **argv)
 	clone_opts.bare = !!bare;
 	clone_opts.checkout_branch = branch;
 	clone_opts.fetch_opts.depth = compute_depth(depth);
+	clone_opts.fetch_opts.proxy_opts.type = GIT_PROXY_AUTO;
 
 	if (!checkout)
 		clone_opts.checkout_opts.checkout_strategy = GIT_CHECKOUT_NONE;
diff --git a/src/cli/progress.h b/src/cli/progress.h
index f08d68f19..0344304ec 100644
--- a/src/cli/progress.h
+++ b/src/cli/progress.h
@@ -58,7 +58,7 @@ typedef struct {
  * @param payload A pointer to the cli_progress
  * @return 0 on success, -1 on failure
  */
-extern int cli_progress_fetch_sideband(
+GIT_EXTERN(int) cli_progress_fetch_sideband(
 	const char *str,
 	int len,
 	void *payload);
@@ -71,7 +71,7 @@ extern int cli_progress_fetch_sideband(
  * @param payload A pointer to the cli_progress
  * @return 0 on success, -1 on failure
  */
-extern int cli_progress_fetch_transfer(
+GIT_EXTERN(int) cli_progress_fetch_transfer(
 	const git_indexer_progress *stats,
 	void *payload);
 
@@ -95,7 +95,7 @@ extern int cli_progress_indexer(
  * @param total_steps The total number of checkout steps
  * @param payload A pointer to the cli_progress
  */
-extern void cli_progress_checkout(
+GIT_EXTERN(void) cli_progress_checkout(
 	const char *path,
 	size_t completed_steps,
 	size_t total_steps,
diff --git a/src/cli/sighandler.h b/src/cli/sighandler.h
index 877223e02..59bb50bbd 100644
--- a/src/cli/sighandler.h
+++ b/src/cli/sighandler.h
@@ -15,6 +15,6 @@
  * @param handler The function to run on interrupt
  * @return 0 on success, -1 on failure
  */
-int cli_sighandler_set_interrupt(void (*handler)(void));
+GIT_EXTERN(int) cli_sighandler_set_interrupt(void (*handler)(void));
 
 #endif /* CLI_sighandler_h__ */
diff --git a/src/cli/win32/sighandler.c b/src/cli/win32/sighandler.c
index 05a67fb14..da56c42f6 100644
--- a/src/cli/win32/sighandler.c
+++ b/src/cli/win32/sighandler.c
@@ -19,7 +19,7 @@ static BOOL WINAPI interrupt_proxy(DWORD signal)
 	return TRUE;
 }
 
-int cli_sighandler_set_interrupt(void (*handler)(void))
+GIT_EXTERN(int) cli_sighandler_set_interrupt(void (*handler)(void))
 {
 	BOOL result;
 
diff --git a/src/libgit2/CMakeLists.txt b/src/libgit2/CMakeLists.txt
index a7d3c7ca4..9e39b3892 100644
--- a/src/libgit2/CMakeLists.txt
+++ b/src/libgit2/CMakeLists.txt
@@ -5,25 +5,29 @@ add_library(libgit2 OBJECT)
 
 include(PkgBuildConfig)
 include(CMakePackageConfigHelpers)
+include(CMakePrintHelpers)
 
 set(LIBGIT2_INCLUDES
 	"${PROJECT_BINARY_DIR}/src/util"
+	"${PROJECT_BINARY_DIR}/src/cli"
 	"${PROJECT_BINARY_DIR}/include"
 	"${PROJECT_SOURCE_DIR}/src/libgit2"
 	"${PROJECT_SOURCE_DIR}/src/util"
+	"${PROJECT_SOURCE_DIR}/src/cli"
 	"${PROJECT_SOURCE_DIR}/include")
 
 # Collect sourcefiles
 file(GLOB SRC_H
 	"${PROJECT_SOURCE_DIR}/include/git2.h"
 	"${PROJECT_SOURCE_DIR}/include/git2/*.h"
-	"${PROJECT_SOURCE_DIR}/include/git2/sys/*.h")
+	"${PROJECT_SOURCE_DIR}/include/git2/sys/*.h"
+	"${PROJECT_SOURCE_DIR}/src/cli/progress.h")
 list(SORT SRC_H)
 target_sources(libgit2 PRIVATE ${SRC_H})
 
 file(GLOB SRC_GIT2 *.c *.h
 	streams/*.c streams/*.h
-	transports/*.c transports/*.h)
+	transports/*.c transports/*.h "${PROJECT_SOURCE_DIR}/src/cli/progress*")
 list(SORT SRC_GIT2)
 target_sources(libgit2 PRIVATE ${SRC_GIT2})
 
@@ -37,6 +41,11 @@ if(APPLE)
 	set_source_files_properties(streams/stransport.c PROPERTIES COMPILE_FLAGS -Wno-deprecated)
 endif()
 
+cmake_print_variables(CURL_DEPENDENCIES_DIR)
+list(APPEND LIBGIT2_SYSTEM_INCLUDES "${CURL_DEPENDENCIES_DIR}\\include")
+list(APPEND LIBGIT2_SYSTEM_LIBS "${CURL_DEPENDENCIES_DIR}\\bin\\libcurl-x64.lib")
+list(APPEND LIBGIT2_PC_LIBS "-lcurl")
+
 ide_split_sources(libgit2)
 list(APPEND LIBGIT2_OBJECTS $<TARGET_OBJECTS:util> $<TARGET_OBJECTS:libgit2> ${LIBGIT2_DEPENDENCY_OBJECTS})
 list(APPEND LIBGIT2_INCLUDES ${LIBGIT2_DEPENDENCY_INCLUDES})
@@ -51,6 +60,26 @@ set(LIBGIT2_DEPENDENCY_OBJECTS ${LIBGIT2_DEPENDENCY_OBJECTS} PARENT_SCOPE)
 set(LIBGIT2_SYSTEM_INCLUDES ${LIBGIT2_SYSTEM_INCLUDES} PARENT_SCOPE)
 set(LIBGIT2_SYSTEM_LIBS ${LIBGIT2_SYSTEM_LIBS} PARENT_SCOPE)
 
+# libcurl
+#find_package(CURL REQUIRED PATHS "C:\\opt\\curl-8.14.1_1-win64-mingw")
+#if(CURL_FOUND)
+	#list(APPEND LIBGIT2_SYSTEM_INCLUDES ${CURL_INCLUDE_DIR})
+	#list(APPEND LIBGIT2_SYSTEM_LIBS ${CURL_LIBRARIES})
+	#list(APPEND LIBGIT2_PC_LIBS ${CURL_LIBRARIES})
+#else()
+	#message(FATAL_ERROR "Curl library and headers not found")
+#endif()
+
+#add_library(Curl SHARED IMPORTED)
+#set_target_properties(Curl PROPERTIES
+#    IMPORTED_LOCATION "${CURL_DEPENDENCIES_DIR}/bin/libcurl-x64.dll"
+#    IMPORTED_IMPLIB "${CURL_DEPENDENCIES_DIR}/bin/libcurl-x64.lib"
+#    INTERFACE_INCLUDE_DIRECTORIES "${CURL_DEPENDENCIES_DIR}/include"
+#)
+
+
+
+
 #
 # Compile and link libgit2
 #
@@ -69,8 +98,6 @@ set_target_properties(libgit2package PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${PROJE
 ide_split_sources(libgit2package)
 
 if(SONAME)
-	set_target_properties(libgit2package PROPERTIES VERSION ${libgit2_VERSION})
-	set_target_properties(libgit2package PROPERTIES SOVERSION "${libgit2_VERSION_MAJOR}.${libgit2_VERSION_MINOR}")
 	if(LIBGIT2_FILENAME)
 		target_compile_definitions(libgit2package PRIVATE LIBGIT2_FILENAME=\"${LIBGIT2_FILENAME}\")
 		set_target_properties(libgit2package PROPERTIES OUTPUT_NAME ${LIBGIT2_FILENAME})
diff --git a/src/libgit2/clone.c b/src/libgit2/clone.c
index 237efc0ba..6f34bdbb1 100644
--- a/src/libgit2/clone.c
+++ b/src/libgit2/clone.c
@@ -24,6 +24,7 @@
 #include "repository.h"
 #include "odb.h"
 #include "net.h"
+#include "progress.h"
 
 static int create_branch(
 	git_reference **branch,
@@ -616,6 +617,21 @@ static int clone_repo(
 
 	GIT_ERROR_CHECK_VERSION(&options, GIT_CLONE_OPTIONS_VERSION, "git_clone_options");
 
+
+	cli_progress progress = CLI_PROGRESS_INIT;
+	git_checkout_options checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;
+
+	/* Set up options */
+	checkout_opts.checkout_strategy = GIT_CHECKOUT_SAFE;
+	checkout_opts.progress_cb = cli_progress_checkout;
+	checkout_opts.progress_payload = &progress;
+	options.checkout_opts = checkout_opts;
+	options.fetch_opts.callbacks.sideband_progress =
+	        cli_progress_fetch_sideband;
+	options.fetch_opts.callbacks.transfer_progress =
+	        cli_progress_fetch_transfer;
+	options.fetch_opts.callbacks.payload = &progress;
+
 	/* enforce some behavior on fetch */
 	options.fetch_opts.update_fetchhead = 0;
 
@@ -641,6 +657,7 @@ static int clone_repo(
 	if ((error = repository_cb(&repo, local_path, options.bare, options.repository_cb_payload)) < 0)
 		return error;
 
+	repo->url = git__strdup(url);
 	if (!(error = create_and_configure_origin(&origin, repo, url, &options))) {
 		bool clone_local;
 
diff --git a/src/libgit2/filter.c b/src/libgit2/filter.c
index 9e0910c8c..a27b55340 100644
--- a/src/libgit2/filter.c
+++ b/src/libgit2/filter.c
@@ -190,7 +190,7 @@ static int filter_registry_insert(
 
 int git_filter_global_init(void)
 {
-	git_filter *crlf = NULL, *ident = NULL;
+	git_filter *crlf = NULL, *ident = NULL, *lfs = NULL;
 	int error = 0;
 
 	if (git_rwlock_init(&filter_registry.lock) < 0)
@@ -205,7 +205,11 @@ int git_filter_global_init(void)
 			GIT_FILTER_CRLF, crlf, GIT_FILTER_CRLF_PRIORITY) < 0 ||
 		(ident = git_ident_filter_new()) == NULL ||
 		filter_registry_insert(
-			GIT_FILTER_IDENT, ident, GIT_FILTER_IDENT_PRIORITY) < 0)
+			GIT_FILTER_IDENT, ident, GIT_FILTER_IDENT_PRIORITY) < 0 ||
+		(lfs = git_lfs_filter_new()) == NULL ||
+		filter_registry_insert(
+			GIT_FILTER_LFS, lfs, GIT_FILTER_LFS_PRIORITY) < 0
+			)
 		error = -1;
 
 	if (!error)
@@ -215,6 +219,7 @@ done:
 	if (error) {
 		git_filter_free(crlf);
 		git_filter_free(ident);
+		git_filter_free(lfs);
 	}
 
 	return error;
diff --git a/src/libgit2/filter.h b/src/libgit2/filter.h
index 58cb4b424..00ddee9f3 100644
--- a/src/libgit2/filter.h
+++ b/src/libgit2/filter.h
@@ -72,6 +72,7 @@ extern int git_filter_list__apply_to_file(
 
 extern git_filter *git_crlf_filter_new(void);
 extern git_filter *git_ident_filter_new(void);
+extern git_filter *git_lfs_filter_new(void);
 
 extern int git_filter_buffered_stream_new(
 	git_writestream **out,
diff --git a/src/libgit2/lfs_filter.c b/src/libgit2/lfs_filter.c
new file mode 100644
index 000000000..4d9555fc3
--- /dev/null
+++ b/src/libgit2/lfs_filter.c
@@ -0,0 +1,479 @@
+/*
+/ Copyright 2025 Intel Corporation
+/
+/ Licensed under the Apache License, Version 2.0 (the "License");
+/ you may not use this file except in compliance with the License.
+/ You may obtain a copy of the License at
+/
+/     http://www.apache.org/licenses/LICENSE-2.0
+/
+/ Unless required by applicable law or agreed to in writing, software
+/ distributed under the License is distributed on an "AS IS" BASIS,
+/ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+/ See the License for the specific language governing permissions and
+/ limitations under the License.
+*/
+
+#include "array.h"
+#include "common.h"
+
+#include "curl/curl.h"
+#include "git2/sys/filter.h"
+#include "filter.h"
+#include "str.h"
+#include "repository.h"
+#include "regexp.h"
+#include "time.h"
+
+typedef struct lfs_attrs
+{
+	const char *path;
+	const char* full_path;
+	const char* workdir;
+	const char *lfs_oid;
+	const char *lfs_size;
+	const char *url;
+} lfs_attrs;
+
+static size_t get_digit(const char *buffer)
+{
+	char *endptr;
+	size_t number = strtoul(buffer, &endptr, 10);
+
+	if (endptr == buffer) {
+		fprintf(stderr, "No digits were found\n");
+	} else if (*endptr != '\0') {
+		fprintf(stderr, "Additional characters after number: %s\n", endptr);
+	}
+
+	return number;
+}
+
+char *append_char_to_buffer(char *existingBuffer, char additionalChar)
+{
+	size_t existingLength = strlen(existingBuffer);
+	char *newBuffer = (char *)malloc((existingLength + 2) * sizeof(char));
+	if (newBuffer == NULL) {
+		return NULL;
+	}
+	strcpy(newBuffer, existingBuffer);
+	newBuffer[existingLength] = additionalChar;
+	newBuffer[existingLength + 1] = '\0';
+	return newBuffer;
+}
+
+int get_lfs_info_match(
+        const git_str *output,
+        const char *regexp)
+{
+	int result;
+	git_regexp preg = GIT_REGEX_INIT;
+	if ((result = git_regexp_compile(&preg, regexp, 0)) < 0) {
+		git_regexp_dispose(&preg);
+		return result;
+	}
+
+	size_t i;
+	git_regmatch pmatch[2];
+
+	if (!git_regexp_search(&preg, output->ptr, 2, pmatch)) {
+		/* use pmatch data to trim line data */
+		i = (pmatch[1].start >= 0) ? 1 : 0;
+		git_str_consume(output, git_str_cstr(output) + pmatch[i].start);
+		git_str_truncate(output, pmatch[i].end - pmatch[i].start);
+		git_str_rtrim(output);
+		git_regexp_dispose(&preg);
+		return 0;
+	}
+
+	git_regexp_dispose(&preg);
+	return -1;
+}
+
+static int lfs_insert_id(
+	git_str *to, const git_str *from, const git_filter_source *src, void** payload)
+{
+	git_str lfs_oid = GIT_STR_INIT;
+	git_str lfs_size = GIT_STR_INIT;
+
+	lfs_oid.size = from->size;
+	lfs_oid.asize = from->asize;
+	lfs_oid.ptr = git__strdup(from->ptr);
+	lfs_size.size = from->size;
+	lfs_size.asize = from->asize;
+	lfs_size.ptr = git__strdup(from->ptr);
+
+	const char *obj_regexp = "\noid sha256:(.*)\n";
+	const char *size_regexp = "\nsize (.*)\n";
+	if (get_lfs_info_match(&lfs_oid, obj_regexp) < 0)
+		return -1;
+
+	if (get_lfs_info_match(&lfs_size, size_regexp) < 0)
+		return -1;
+
+	git_repository *repo = git_filter_source_repo(src);
+	const char *path = git_filter_source_path(src);
+
+	git_str full_path = GIT_STR_INIT;
+	if (git_repository_workdir_path(&full_path, repo, path) < 0)
+		return -1;
+
+	size_t workdir_size = strlen(git_repository_workdir(repo));
+
+	const char *workdir = git_repository_workdir(repo);
+	struct lfs_attrs la = { path, full_path.ptr, workdir, lfs_oid.ptr, lfs_size.ptr,  repo->url };
+
+	*payload = git__malloc(sizeof(la));
+	GIT_ERROR_CHECK_ALLOC(*payload);
+	memcpy(*payload, &la, sizeof(la));
+
+	/*Just write the oryginal lfs file contents */ 
+	return git_str_set(to, from->ptr, from->size);
+}
+
+static int lfs_apply(
+	git_filter     *self,
+	void          **payload,
+	git_str        *to,
+	const git_str  *from,
+	const git_filter_source *src)
+{
+	GIT_UNUSED(self); GIT_UNUSED(payload);
+
+	if (git_filter_source_mode(src) == GIT_FILTER_SMUDGE)
+		return lfs_insert_id(to, from, src, payload);
+	/*else
+	* PATH for upload lfs files not needed
+		return lfs_remove_id(to, from);
+		*/
+	return 0;
+}
+
+static int lfs_check(
+        git_filter *self,
+        void **payload, /* points to NULL ptr on entry, may be set */
+        const git_filter_source *src,
+        const char **attr_values)
+{
+	const char *value;
+
+	git_repository *repo = git_filter_source_repo(src);
+	const char *path = git_filter_source_path(src);
+
+	git_attr_get(
+	        &value, repo, GIT_ATTR_CHECK_NO_SYSTEM, path, "filter");
+
+	if (value && *value) {
+		if (strcmp(value, "lfs") == 0) {
+			return 0;
+		}
+	} else {
+		return GIT_PASSTHROUGH;
+	}
+
+	GIT_UNUSED(self);
+
+	return 0;
+}
+
+static int lfs_stream(
+	git_writestream **out,
+	git_filter *self,
+	void **payload,
+	const git_filter_source *src,
+	git_writestream *next)
+{
+	return git_filter_buffered_stream_new(out,
+		self, lfs_apply, NULL, payload, src, next);
+}
+
+struct memory {
+	char *response;
+	size_t size;
+};
+
+struct FtpFile {
+	const char *filename;
+	FILE *stream;
+	size_t full_size;
+	size_t already_copied;
+	time_t started_download;
+	time_t last_write_call;
+};
+
+static void print_download_speed_info(size_t received_size, size_t elapsed_time)
+{
+	double recv_len = (double)received_size;
+	char *rate_units[] = { "B/s", "KiB/s", "MiB/s", "GiB/s", "TiB/s", NULL };
+	uint64_t elapsed = (uint64_t)elapsed_time;
+	double rate;
+	rate = elapsed ? recv_len / elapsed : received_size;
+
+	size_t rate_unit_idx = 0;
+	while (rate > 1024 && rate_units[rate_unit_idx + 1]) {
+		rate /= 1024.0;
+		rate_unit_idx++;
+	}
+	
+	printf(" [%.2f %s] ", rate, rate_units[rate_unit_idx]);
+}
+
+void print_progress(size_t count, size_t max, bool first_run, size_t elapsed_time)
+{
+	float progress = (float)count / max ;
+	if (!first_run && progress < 0.01 && count > 0)
+		return;
+
+	const int bar_width = 50;
+	int bar_length = progress * bar_width;
+
+	printf("\rProgress: [");
+	int i;
+	for (i = 0; i < bar_length; ++i) {
+		printf("#");
+	}
+	for (i = bar_length; i < bar_width; ++i) {
+		printf(" ");
+	}
+	printf("] %.2f%%", progress * 100);
+	print_download_speed_info(count, elapsed_time);
+	if (progress == 1.0)
+		printf("\n");
+	fflush(stdout);
+}
+
+static size_t file_write_callback(void *buffer, size_t size, size_t nmemb, void *stream)
+{
+	struct FtpFile *out = (struct FtpFile *)stream;
+	if (!out->stream) {
+		/* open file for writing */
+		out->stream = fopen(out->filename, "wb");
+		if (!out->stream) {
+			fprintf(stderr, "failure, cannot open file to write: %s\n",
+			        out->filename);
+			return 0; /* failure, cannot open file to write */
+		}
+	}
+	bool first_run = false;
+	if (out->already_copied == 0)
+		first_run = true;
+
+	out->already_copied += size * nmemb;
+	time_t currentTime = time(NULL);
+	if (currentTime - out->last_write_call >= 1 ||
+	    out->already_copied == out->full_size) {
+		print_progress(
+		        out->already_copied, out->full_size, first_run,
+		        currentTime - out->started_download );
+		out->last_write_call = currentTime;
+	}
+	
+	return fwrite(buffer, size, nmemb, out->stream);
+}
+
+static size_t write_callback(void *ptr, size_t size, size_t nmemb, void *userp)
+{
+	size_t realsize = size * nmemb;
+	struct memory *mem = (struct memory *)userp;
+
+	char *ptr_new = realloc(mem->response, mem->size + realsize + 1);
+	if (ptr_new == NULL) {
+		return 0; /* out of memory! */
+	}
+
+	mem->response = ptr_new;
+	memcpy(&(mem->response[mem->size]), ptr, realsize);
+	mem->size += realsize;
+	mem->response[mem->size] = 0;
+
+	return realsize;
+}
+
+static void print_download_info(const char* filename, size_t bytes)
+{
+	double recv_len = (double)bytes;
+	size_t recv_unit_idx = 0;
+	char *recv_units[] = { "B", "KiB", "MiB", "GiB", "TiB", NULL };
+	while (recv_len > 1024 && recv_units[recv_unit_idx + 1]) {
+		recv_len /= 1024.0;
+		recv_unit_idx++;
+	}
+	printf("\nDownloading lfs size: %.2f %s file: %s\n", recv_len, recv_units[recv_unit_idx], 
+	       filename);
+}
+
+static void lfs_download(git_filter *self, void *payload)
+{
+	GIT_UNUSED(self);
+	if (!payload) {
+		fprintf(stderr, "lfs payload not initialized");
+		return;
+	}
+	struct lfs_attrs *la = (struct lfs_attrs *)payload;
+	char *tmp_out_file = append_char_to_buffer(la->full_path, '2');
+
+	CURL *info_curl,*dl_curl;
+	CURLcode res;
+	git_str res_str = GIT_STR_INIT;
+	/* get a curl handle */
+	info_curl = curl_easy_init();
+	if (info_curl) {
+		struct curl_slist *chunk = NULL;
+		git_str lfs_info_url = GIT_STR_INIT;
+		if (git_str_join(
+		            &lfs_info_url, '.',
+		            la->url,
+		            "git/info/lfs/objects/batch") < 0) {
+			fprintf(stderr, "failed to create url '%s'",
+			        la->full_path);
+			goto on_error;
+		}
+
+		/* Remove a header curl would otherwise add by itself */
+		chunk = curl_slist_append(chunk, "Accept: application/vnd.git-lfs+json");
+		/* Add a custom header */
+		chunk = curl_slist_append(chunk, "Content-type: application/json");
+		/* set our custom set of headers */
+		curl_easy_setopt(info_curl, CURLOPT_HTTPHEADER, chunk);
+		/* First set the URL that is about to receive our POST. This URL
+		   can just as well be an https:// URL if that is what should
+		   receive the data. */
+		curl_easy_setopt(info_curl, CURLOPT_URL, lfs_info_url.ptr);
+
+		git_str lfs_info_data = GIT_STR_INIT;
+
+		/* "{\"operation\":\"download\",\"transfer\":[\"basic\"],\"objects\":[{\"oid\":\"9556d0a12310629e217450ac4198c49f5457f1a69e22ce7c9f8e81fab4d530a7\",\"size\":499723}]}" */
+		if (git_str_join_n(
+		            &lfs_info_data, '"',5,
+		            "{\"operation\":\"download\",\"transfer\":[\"basic\"],\"objects\":[{\"oid\":",
+			    la->lfs_oid,
+			    ",\"size\":",
+			    la->lfs_size,
+			    "}]}" ) < 0) {
+			fprintf(stderr, "failed to create url '%s'",
+			        la->full_path);
+			/* always cleanup */
+			curl_easy_cleanup(info_curl);
+			/* free the custom headers */
+			curl_slist_free_all(chunk);
+			goto on_error;
+		}
+
+		/* Now specify the POST data */
+		curl_easy_setopt(info_curl, CURLOPT_POSTFIELDS, lfs_info_data.ptr);
+		curl_easy_setopt(info_curl, CURLOPT_SSL_OPTIONS, CURLSSLOPT_NATIVE_CA);
+		curl_easy_setopt(info_curl, CURLOPT_FOLLOWLOCATION, 1L);
+
+		struct memory response = { 0 };
+		curl_easy_setopt(
+		        info_curl, CURLOPT_WRITEFUNCTION, write_callback);
+		curl_easy_setopt(
+		        info_curl, CURLOPT_WRITEDATA, (void *)&response);
+
+		/* Perform the request, res gets the return code */
+		res = curl_easy_perform(info_curl);
+		/* Check for errors */
+		if (res != CURLE_OK) {
+			fprintf(stderr, "curl_easy_perform() failed: %s\n",
+			        curl_easy_strerror(res));
+			/* always cleanup */
+			curl_easy_cleanup(info_curl);
+			/* free the custom headers */
+			curl_slist_free_all(chunk);
+			goto on_error;
+		}
+
+		/* Get response data */
+		res_str.asize = response.size;
+		res_str.size = response.size;
+		res_str.ptr = git__strdup(response.response);
+		/* always cleanup */
+		curl_easy_cleanup(info_curl);
+		/* free the custom headers */
+		curl_slist_free_all(chunk);
+	}
+
+	/* get a curl handle */
+	dl_curl = curl_easy_init();
+	if (dl_curl) {
+		struct FtpFile ftpfile = { tmp_out_file, NULL,
+					   get_digit(la->lfs_size), 0,
+			                   time(NULL), time(NULL) };
+
+		const char *href_regexp = "{\"href\":\"(.*)\"}}}]}";
+		if (get_lfs_info_match(&res_str, href_regexp) < 0) {
+			/* always cleanup */
+			curl_easy_cleanup(dl_curl);
+			goto on_error;
+		}
+		/* First set the URL that is about to receive our POST. This URL
+		   can just as well be an https:// URL if that is what should
+		   receive the data. */
+		curl_easy_setopt(dl_curl, CURLOPT_URL, res_str.ptr);
+		curl_easy_setopt(dl_curl, CURLOPT_SSL_OPTIONS, CURLSSLOPT_NATIVE_CA);
+		curl_easy_setopt(dl_curl, CURLOPT_FOLLOWLOCATION, 1L);
+		curl_easy_setopt(dl_curl, CURLOPT_USE_SSL, CURLUSESSL_ALL);
+		curl_easy_setopt(dl_curl, CURLOPT_WRITEFUNCTION, file_write_callback);
+		curl_easy_setopt(dl_curl, CURLOPT_WRITEDATA, (void *)&ftpfile);
+
+		print_download_info(la->full_path, ftpfile.full_size);
+		/* Perform the request, res gets the return code */
+		res = curl_easy_perform(dl_curl);
+		/* Check for errors */
+		if (res != CURLE_OK) {
+			fprintf(stderr, "curl_easy_perform() failed: %s\n",
+			        curl_easy_strerror(res));
+			if (ftpfile.stream)
+				fclose(ftpfile.stream);
+			/* always cleanup */
+			curl_easy_cleanup(dl_curl);
+			goto on_error;
+		}
+
+		if (ftpfile.stream)
+			fclose(ftpfile.stream);
+		/* always cleanup */
+		curl_easy_cleanup(dl_curl);
+	}
+
+	/* Remove lfs file and rename downloaded file to oryginal lfs filename */ 
+	if (p_unlink(la->full_path) < 0) {
+		fprintf(stderr, "failed to delete file '%s'", la->full_path);
+		goto on_error;
+	}
+
+	if (p_rename(tmp_out_file, la->full_path) < 0) {
+		fprintf(stderr, "failed to rename file to '%s'", la->full_path);
+		goto on_error;
+	}
+	git__free(payload);
+	return;
+
+on_error:
+	git__free(payload);
+	return;
+}
+
+void git_lfs_filter_free(git_filter *filter)
+{
+	curl_global_cleanup();
+	git__free(filter);
+}
+
+git_filter *git_lfs_filter_new(void)
+{
+	/* In Windows, this inits the Winsock stuff */
+	curl_global_init(CURL_GLOBAL_ALL);
+	git_filter *f = git__calloc(1, sizeof(git_filter));
+	if (f == NULL)
+		return NULL;
+
+	f->version = GIT_FILTER_VERSION;
+	f->attributes = "lfs";
+	f->shutdown = git_lfs_filter_free;
+	f->stream   = lfs_stream;
+	f->check = lfs_check;
+	f->cleanup = lfs_download;
+
+	return f;
+}
diff --git a/src/libgit2/repository.c b/src/libgit2/repository.c
index 73876424a..6c267bc98 100644
--- a/src/libgit2/repository.c
+++ b/src/libgit2/repository.c
@@ -190,6 +190,7 @@ void git_repository_free(git_repository *repo)
 	git__free(repo->namespace);
 	git__free(repo->ident_name);
 	git__free(repo->ident_email);
+	git__free(repo->url);
 
 	git__memzero(repo, sizeof(*repo));
 	git__free(repo);
diff --git a/src/libgit2/repository.h b/src/libgit2/repository.h
index fbf143894..1890c61c1 100644
--- a/src/libgit2/repository.h
+++ b/src/libgit2/repository.h
@@ -168,6 +168,7 @@ struct git_repository {
 
 	intptr_t configmap_cache[GIT_CONFIGMAP_CACHE_MAX];
 	git_submodule_cache *submodule_cache;
+	char *url;
 };
 
 GIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)
